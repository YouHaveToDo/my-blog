---
title: 코어 자바스크립트) 01. 데이터 타입
date: '2022-11-23'
tags: ['자바스크립트']
draft: false
summary: 자바스크립트의 기본형과 참조형 데이터 타입을 알아보자!
images: []
---

# 1. 데이터 타입 (종찬)

## 01. 데이터 타입의 종류

![스크린샷 2022-11-20 오후 8.14.32.png](/static/images/javascript/javascript01/01.png)

자바스크립트는 크게 **기본형과 참조형** 2가지로 나누어진다.

2가지를 나누는 기준은 데이터를 어떻게 할당하는지에 따라 구분되어진다.

어떠한 기준을 가지고 있는지 알기 위해 **불변성**을 알아보자.

## 02. 데이터 타입에 관한 배경지식

메모리에 대한 이해가 필요. 대충 값을 저장할 때 **메모리의 주소**를 통해 구분하고 연결한다.

- 식별자와 변수 (구분할 필요가 있음)

변수: 변할 수 있는 값
식별자: 데이터를 식별하기 위한 이름 즉, 변수명

## 03.변수 선언과 데이터 할당

### 1-3-1 변수 선언

```javascript
var a
```

위 코드를 해석해보면, “변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다” 라는 의미가 될 수 있다.

즉, 변수란 값을 담는 그릇이라고 볼 수 있다.

![스크린샷 2022-11-20 오후 8.33.19.png](/static/images/javascript/javascript01/02.png)

### 1-3-2 데이터 할당

변수는 데이터를 담는 그릇이라고 했으니, 데이터를 담아보자.

```javascript
var a
a = 'abc'

var a = 'abc'
```

위 예시 처럼, 변수를 선언 후 값을 할당할 수도 있고, 변수 선언과 할당을 동시에 할 수도 있다

변수를 사용하다보면 오해할 수 있는 것이 변수와 데이터를 같은 메모리 주소에 저장할 것이라고 생각하곤 하지만, 실제로는 그렇지 않다.

![스크린샷 2022-11-20 오후 8.37.50.png](/static/images/javascript/javascript01/03.png)

실제로는 메모리에 변수 영역과 데이터 영역을 나누어 변수 영역에는 변수명과 값이 담겨있는 데이터 영역의 주소를 저장하고 데이터 영역의 빈 공간에 값을 할당한다. 위 사진은 그 예시다.

이렇게 변수명과 데이터를 같은 메모리 주소에 저장하지 않은 이유는 변수의 데이터 할당을 자유롭게 하고 메모리를 효율적으로 사용하기 위함이다.

데이터에 타입에 따라 필요로 하는 공간이 다르기 때문에 미리 크기가 정해진 공간에 새로운 값을 할당하기 위해서는 공간을 변화시키는 과정이 필요하고 만약 메모리 중간에 저장되어 있는 값을 수정할 경우에는 필요한 크기만큼 다른 메모리값들을 옮기고 할당하는 과정이 필요하다. 이 과정은 많은 컴퓨터 연산을 필요하게 한다.

![만약 2와 1사이에 새로운 값을 넣는다고 생각해보자 2뒤에 있는 모든 수를 한칸씩 미뤄야한다.](/static/images/javascript/javascript01/04.png)

만약 2와 1사이에 새로운 값을 넣는다고 생각해보자 2뒤에 있는 모든 수를 한칸씩 미뤄야한다.

### 04.기본형 데이터와 참조형 데이터

### 1-4-1 불변값

변수와 상수를 구분하는 성질은 ‘변경 가능성’이다. 하나, 불변값과 상수를 같은 개념으로 오해할 수 있으나, 이는 서로 다른 개념이다.

변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역**이고
불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역**이다.

![스크린샷 2022-11-20 오후 8.50.45.png](/static/images/javascript/javascript01/05.png)

### 1-4-2 가변값

참조형 데이터는 모두 가변값일 것 같은 느낌이 든다. 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다.

![스크린샷 2022-11-20 오후 8.52.37.png](/static/images/javascript/javascript01/06.png)

참조형 데이터를 변수에 할당하는 과정을 살펴보자.

![스크린샷 2022-11-20 오후 8.53.28.png](/static/images/javascript/javascript01/07.png)

1. 변수영역에 변수명과 데이터 주소를 할당하고
2. 데이터 영역에는 객체 변수에 사용되는 변수영역의 주소를 할당
3. 변수 영역에는 속성 명과 값이 들어있는 데이터 영역의 주소를 할당
4. 데이터 영역에 속성 값에 필요한 데이터를 할당.

데이터 영역에 저장된 값은 모두 불변값이다. 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 그렇기 때문에 참조형 데이터는 불변하지 않다 라고 한다.

예시를 보자.

```javascript
var obj1 = {
  a: 1,
  b: 'bbb',
}

obj1.a = 2
```

![스크린샷 2022-11-22 오전 12.00.47.png](/static/images/javascript/javascript01/08.png)

메모리 @1002에 저장되어 있는 값은 여전히 @5001를 보고 있고, @7103의 값이 @5003에서 @5005로 변경된 것을 볼 수 있다.

즉, 새로운 객체가 만들어진 것이 아닌, 객체 내부의 값만 바뀐 것이다.

다음으로 참조형 데이터에 참조형 데이터가 속성으로 있는 중첩 객체의 경우를 보자.

![스크린샷 2022-11-22 오전 12.07.52.png](/static/images/javascript/javascript01/09.png)

![스크린샷 2022-11-22 오전 12.09.02.png](/static/images/javascript/javascript01/10.png)

만약 이 상태에서 아래의 경우와 같이 재할당을 하면 어떻게 될까.

```javascript
obj.arr = 'str'
```

배열에서 문자로 데이터 타입이 변경되었기 때문에,

더이상 배열@5003의 변수 영역은 사용하지 않고 ‘str’이라는 값이 데이터 영역에 있는지 확인 후 비어있는 데이터 영역에 ‘str’이라는 값을 넣고 @7104의 값에는 새로운 데이터 영역의 주소가 들어갈 것이다.

이후 사용하지 않는 @8104 ~ @8106은 가비지 컬렉터의 의해 메모리에서 삭제될 것이다.

### 1-4-3 변수 복사 비교

기본형과 참조형 데이터의 차이를 확인해보자.

---

변수를 복사 할 경우

```javascript
var a = 10
var b = a

var obj1 = { c: 10, d: 'ddd' }
var obj2 = obj1
```

변수를 복사하는 과정은 기본형과 참조형 모두 값이 들어있는 데이터 영역의 주소를 복사하게 된다.

---

변수 복사 이후 값을 변경 할 경우 - 객체의 프로퍼티를 변경했을 때

```javascript
var a = 10
var b = a
var obj1 = { c: 10, d: 'ddd' }
var obj2 = obj1

b = 15
obj2.c = 20
```

복사 이후 값을 변경하는 경우에는 기본형은 새로운 값을 생성하고 새로운 값의 주소를 할당하기 때문에 a, b가 바라보는 값의 주소가 다르게 되고, 객체의 경우 객체 변수의 주소는 그대로 유지한 채, 객채 변수 안에 있는 속성의 값의 주소가 변경되기 때문에 변수의 값이 변하지 않게 된다.

![스크린샷 2022-11-22 오전 12.28.48.png](/static/images/javascript/javascript01/11.png)

---

변수 복사 이후 값을 변경 할 경우 - 객체 자체를 변경했을 때

```javascript
var a = 10;
var b = a;
var obj1 = { c: 10, d:’ddd’ };
var obj2 = obj1;

b = 15;
obj2 = { c:20, d:'ddd' };
```

- 위 와 같은 경우에는 마지막줄에 기존 오브젝트2가 오브젝트1 값의 주소를 복사한 것이 아닌 새로운 { c:20, d:'ddd' } 이라는 객체를 생성하고 할당 받은 것이기 때문에 서로 다른 주소를 가지게 된다.

- 즉, 객체의 프로퍼티에 접근하여 수정할 경우는 가변이 일어나고,

- 새로운 객체를 만들어 변경했을 때는 불변성이 일어나게 된다.

## 05.불변 객체

### 1-5-1 불변 객체를 만드는 간단한 방법

객체의 가변성에 따른 문제점은 위에서 설명했다.

그렇다면 이러한 문제점을 해결하는 방법에는 무엇이 있는지 알아보자.

- 새로운 객체를 만들어서 할당하는 방법
  ![스크린샷 2022-11-22 오전 12.37.16.png](/static/images/javascript/javascript01/12.png)
  위 코드에서 changeName이라는 함수는 인자로 받은 user의 속성에 접근하여 값을 변경시키는 것이 아닌, user.gender와 newName 의 값을 가져와 새로운 객체를 만들고 데이터 영역에 할당했기 때문에 user 객체에 프로퍼티에 직접 수정한 것이 아니며 같은 객체의 주소를 공유하지 않게 된다..
  하지만 위와 같은 함수는 객체 속성의 갯수가 적을 경우에는 괜찮지만, 많아질 경우 하드코딩으로는 효율성이 떨어지게 되기 때문에 반복문을 돌면서 객체를 복사하는 함수를 사용할 수 있다.
- 반복문을 활용한 객체 복사 방법(얇은 복사)
  ![스크린샷 2022-11-22 오전 12.41.49.png](/static/images/javascript/javascript01/13.png)
  위 코드에서는 직접 속성의 이름을 적는 것이 아닌, 객체의 속성을 하나씩 돌면서 result라는 새로운 객체에 만들고 할당하기 때문에 불변객체를 만들 수 있다.
  여기도 문제가 있다. 기본형 데이터의 경우에는 상관 없지만, 객체 안에 참조형 데이터가 있는 경우에는 target의 바로 아래에 있는 속성만 복사하기 때문에 얇은 복사만 하게 되고, 불변 객체를 생성할 수 없다.

  ### 1-5-2 얇은 복사와 깊은 복사

  ![스크린샷 2022-11-22 오전 12.47.28.png](/static/images/javascript/javascript01/14.png)
  user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면,
  한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하고 있다.
  이런 현상이 발생하지 않게 하려면 user.urls 프로퍼티에 대해서도 불변 객체로 만들 필요가 있다.
  ![스크린샷 2022-11-22 오전 12.48.56.png](/static/images/javascript/javascript01/15.png)
  객체의 속성의 타입이 객체이거나 빈 값이 아닌지 확인하고 조건을 통과할 경우,
  재귀함수를 호출하여 바로 아래 단계가 아닌 깊은 단계까지 새로운 값을 생성하고 불변성을 유지하는
  깊은 복사를 할 수 있다.
  책에서는 JSON을 활용한 간단한 깊은 복사 방법을 하나 더 설명하는데, 나는 이 방법을 실제로 코드에서 많이 쓰는 편이다.
  객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이다.
  실제 코드를 보면,
  ![스크린샷 2022-11-22 오전 12.55.55.png](/static/images/javascript/javascript01/16.png)
  propsChartData라는 객체를 JOSN 문자열로 변환한 후 다시 파싱의 단계를 거쳐 새로운 객체를 만들어
  사용할 수 있다.

  ## 06.undefined와 null

  자바스크립트에서 ‘없음’을 나타내는 값이 두가지 있다.
  **undefined**
  undefined가 사용자가 의도를 가지고 지정할 수 도 있지만,
  우리는 컴퓨터가 자동으로 부여해주는 경우를 알아보자.

  1. 값을 대입하지 않은 변수
  2. 객체 내부에 존재하지 않는 프로퍼티에 접근하려고 할 때
  3. return 문이 없거나 호출되지 않는 함수의 실행결과

  ```javascript
  var a
  console.log(a) // (1) undefined. 값을 대입하지 않은 변수에 접근

  var obj = { a: 1 }
  console.log(obj.a) // 1
  console.log(obj.b) // (2) 존재하지 않는 프로퍼티에 접근
  console.log(b) // c.f) ReferenceError: b is not defined

  var func = function () {}
  var c = func() // (3) 반환(return) 값이 없으면 undefined를 반환한 것으로 간주.
  console.log(c) // undefined
  ```

  위에 예시와는 다르게 배열에서는 값을 대입하지 않는 경우 다르게 작동하기도 한다.
  예시를 보자.
  ![스크린샷 2022-11-23 오후 8.02.53.png](/static/images/javascript/javascript01/17.png)
  undefined와 하나의 값인 것에 비해,
  empty라는 값은 변수의 값에 정말 아무것도 존재하지 않는 것을 의미한다.
  ![스크린샷 2022-11-23 오후 8.05.41.png](/static/images/javascript/javascript01/18.png)
  배열에 filter 메서드를 통해 값을 리턴 받으려고 했지만 빈 배열이 나온 이유는 존재하지 않은 프로퍼티에 대해서 접근하여 순회하려고 했기 때문이다.
  즉, undefined는 비어있음을 의미하는 하나의 값으로서 동작하고, empty는 실존하지 않는 값임을 알려준다
  undefined가 “비어있음"을 의미하며 사용자가 할당할 수 도 있고, 컴퓨터가 자동적으로 할당할 수도 있다고 했지만 사용자의 입장에서 코드를 작성할 때는 “비어있음”을 나타내기 위해 null을 사용하도록 하자.
  undefined와 null을 구분함으로서, 의도를 가지고 “비어있음”을 나타내는 것인지 아닌지 알 수 있기 때문이다.
  여기서 주의할 점은 null의 타입은 object, undefined의 타입은 undefined라는 것이다.
  타입을 비교할 때, 이점을 주의하며 사용해야 한다.
  ![스크린샷 2022-11-23 오후 8.14.51.png](/static/images/javascript/javascript01/19.png)

---

##### 해당 스터디는 팀원들과 함께 진행한 스터디이기에 모든 장을 혼자서 발표한 것이 아닙니다.

##### 다른 장도 궁금하다면 [노션](https://amplified-neptune-cfd.notion.site/d09e6d5341d94dbdb0d51df230a138fa)을 방문해주세요 :)
