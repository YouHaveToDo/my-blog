---
title: 혼자 공부하는 컴퓨터구조와 운영체제) 05. CPU 성능 향상 기법
date: '2022-10-06'
tags: ['컴퓨터구조', '운영체제']
draft: false
summary: 여러 개의 코어를 가진 멀티 코어, 멀티 쓰레드 고클럭 컴퓨터라도 어차피 자바스크립트는 싱글스레드로 프로그램을 수행하는 데 성능과 연관성이 있을까 ?
images: []
---

# 05. CPU 성능 향상 기법(코비)

# 05 - 1. 빠른 CPU를 위한 설계 기법

**같이 생각해 봅시다!**

2021년 12월 부트캠프 마지막 실전 프로젝트를 하는 과정 속에서 자바스크립트의 싱글스레드와
AWS EC2 1코어 1쓰레드 컴퓨터의 연관성에 대해 궁금증을 가지게 됩니다.

**여러 개의 코어를 가진 멀티 코어, 멀티 쓰레드 고클럭 컴퓨터라도 어차피 자바스크립트는 싱글스레드로 프로그램을 수행하는 데 성능과 연관성이 있을까 ?**

일단 클럭, 코어, 쓰레드부터 공부해 봅시다!

![image01](/static/images/cs/cs05/01.png)

피시방을 가보면 이런 팜플릿을 볼 수(띄어쓰고 싶다.)밖에 없다.

여기서 다른 분들은 CPU 부분이 어디고 아래 설명은 무엇을 의미하는지 아시나요 ?

## 클럭

- 컴퓨터의 머리 역할을 하는 CPU의 성능과 실행시킨 프로그램의 속도에는 중요한 관계가 있다.

![image01-1](/static/images/cs/cs05/01-1.png)

- 일반적으로 클럭의 속도가 높을수록 CPU의 성능이 향상됩니다.
  → 클럭 신호가 빠르게 반복되면 CPU를 비롯한 PC 부품들이 빠른 속도에 맞춰 작동하기 때문!

- 클럭의 속도는 헤르츠(Hz) 단위로 측정
  - 1초에 한 번 움직이면 1Hz, 100번 움직이면 100Hz

![우리가 사용하는 M1 에어 클럭 예시 ](/static/images/cs/cs05/2.png)

우리가 사용하는 M1 에어 클럭 예시

**그렇다면 위 사진의 오버클럭은 무엇을 의미할까?**

![스크린샷 2022-10-06 오후 1.43.02.png](/static/images/cs/cs05/3.png)

클럭의 속도는 일정하지 않다.

필요할 땐 빠르게, 필요 없을 땐 천천히 속도를 조절한다.

게임을 예시로 들어보면 모니터 같은 화면은 실제 우리의 눈처럼 연속된 장면을 보여주는 것이 아닌

사진을 연속으로 찍어서 연결해서 보여주는 것 !

그래서 모니터에도 CPU 클럭과 비슷하게 화면을 그려주는 빈도(주사율)를 Hz라는 단위로 표현하고 있다.

![스크린샷 2022-10-06 오후 1.49.01.png](/static/images/cs/cs05/4.png)

![위 사진은 Hz 아래는 FPS 차이점 설명 듣고 싶으신가요 ?](/static/images/cs/cs05/5.png)

위 사진은 Hz 아래는 FPS 차이점 설명 듣고 싶으신가요 ?

안정된 프레임 유지를 위해서는 컴퓨터의 연산 처리를 빠르게 해서 클럭 속도를 높여 여러 번 화면을 다시 그려주는 것이 중요하다.

그래서 우리는 CPU의 필요 이상의 전력을 주고(밥을 더 많이 준다고 생각하면 편함) 클럭 속도를 강제로 끌어올리는데, 이걸 오버클럭이라고 합니다.

그러면 오버클럭이 무조건 좋은가? 그건 아니지..

![스크린샷 2022-10-06 오후 1.58.50.png](/static/images/cs/cs05/6.png)

사람이 지속적으로 뛰거나 운동을 하면 몸에서 열이 높아지듯, 컴퓨터도 과도하게 일을 하면 열을 발생시키고 열로 인해 성능이 저하되는 쓰로틀링이나 수명 저하 문제가 발생합니다.

![열을 식혀주는 쿨러가 필요합니다. 쿨러 설명 필요하신가요?](/static/images/cs/cs05/7.png)

열을 식혀주는 쿨러가 필요합니다. 쿨러 설명 필요하신가요?

[공냉 vs 수냉 쿨러 성능비교 (1열, 2열, 3열)](https://papipustory.tistory.com/17)

## 코어와 멀티코어

클럭 속도를 높이는 것 이외에도 CPU의 성능을 높이는 방법에는 CPU의 일꾼 같은 코어와 스레드를 늘리는 방법이 있다.

과거에는 명령어를 처리하는 코어의 개수가 1개밖에 없는 싱글코어가 주를 이루었으나, 오늘날에는 코어가 2개 이상 가지고 있는 **멀티코어** 제품들이 주가 되었습니다.

![스크린샷 2022-10-06 오후 2.17.45.png](/static/images/cs/cs05/8.png)

즉! 일꾼 코어의 수가 증가함에 따라 CPU의 성능이 향상될 수 있습니다.

따라서, 2.4GHz 단일 코어 보다 1.9GHz 멀티코어 CPU가 일반적으로 성능이 좋을 수 있습니다.

상황에 따라 단일 코어만을 사용하는 작업에서는 후자보다 전자의 경우가 더 빠른 경우도 있습니다.

![사진 속 피시방의 컴퓨터는 코어를 6개 가진 멀티코어 CPU이다! ](/static/images/cs/cs05/4.png)

사진 속 피시방의 컴퓨터는 코어를 6개 가진 멀티코어 CPU이다!

![우리가 사용하는 M1 에어는 8코어.. 이지만 4성능, 4효율이라 조금 다를 수 있다!!!! ](/static/images/cs/cs05/3.png)

우리가 사용하는 M1 에어는 8코어.. 이지만 4성능, 4효율이라 조금 다를 수 있다!!!!

## 스레드와 멀티스레드

![스크린샷 2022-10-06 오후 2.24.11.png](/static/images/cs/cs05/9.png)

스레드의 두가지로 분류할 수 있습니다!!

- 하드웨어적 스레드
  - ‘하나의 코어가 동시에 처리하는 명령어 단위’
  - 1 코어 1 스레드는 1개의 코어가 동시에 하나의 명령어 밖에 처리 못함.
  - 멀티스레드는 1개의 코어가 2개 이상의 명령어를 동시에 처리
    ![사실 한 코어당 3스레드 이상을 본 적이 없습니다. ](/static/images/cs/cs05/10.png)
    사실 한 코어당 3스레드 이상을 본 적이 없습니다.
    인텔에서는 자신들의 멀티 스레드 기술에 하이퍼스레딩이라는 이름을 부여했지만 음….
- 소프트웨어적 스레드
  - ‘하나의 프로그램에서 독립적으로 실행되는 단위’
    ![스크린샷 2022-10-06 오후 2.29.55.png](/static/images/cs/cs05/11.png)
  - 한번에 하나의 명령어를 처리하는 싱글스레드와 2개 이상의 명령어를 처리하는 멀티스레드
    ![2가지 일을 동시에](/static/images/cs/cs05/12.png)
    2가지 일을 동시에

정리하면, 스레드의 하드웨어적 정의는 ‘하나의 코어가 동시에 처리하는 명령어 단위’룰 의미하고 소프트웨어적 정의는 ‘하나의 프로그램에서 독립적으로 실행되는 단위’를 의미합니다.

- 멀티스레드 프로세서
  - 핵심은 레지스터(프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터 등등…)
    ![스크린샷 2022-10-06 오후 2.36.41.png](/static/images/cs/cs05/13.png)
  - 컴퓨터가 보기에는 코어나 스레드나 똑같다고 판단!
  - 결국 위 그림으로 보면 CPU가 4개 있다고 판단하게 됩니다.
  - 그래서 하드웨어 스레드를 논리 프로세서라고 부르기도 합니다.

## 05 - 2 명령어 병렬 처리 기법

CPU가 놀지 않고 시간을 알뜰하게 쓸 수 있는 방법을 알아보자!

- 명령어 병렬 처리 기법 : 명령을 병렬적으로 동시에 처리하도록 작동시키는 기법

  1. 명령어 파이프라인

     - 명령어 처리 과정(클럭 단위)
       1. 명령어 인출
       2. 명령어 해석
       3. 명령어 실행
       4. 결과 저장
     - 단계만 겹치지 않으면 CPU는 각 단계를 동시에 실행할 수 있음.
     - 여러개의 명령어 파이프 라인을 넣고 처리하는 기법을 명령어 파이프라이닝
       ![스크린샷 2022-10-06 오후 2.50.48.png](/static/images/cs/cs05/14.png)

       - 파이프라인 위험 종류 3가지
         ![스크린샷 2022-10-06 오후 2.51.26.png](/static/images/cs/cs05/15.png)

         1. 데이터 위험

            ![스크린샷 2022-10-06 오후 2.53.57.png](/static/images/cs/cs05/16.png)

            다음 명령어가 이전 명령어의 결과에 의한 데이터 의존성에 의해 발생.

            Like 콜백지옥, 재귀함수

            ![스크린샷 2022-10-06 오후 2.55.26.png](/static/images/cs/cs05/17.png)

         2. 제어 위험

            ![스크린샷 2022-10-06 오후 3.00.31.png](/static/images/cs/cs05/18.png)

            다음 차례에 실행될 명령어들을 미리 처리하였으나, 앞서 실행 중이던 명령어의 프로그램 카운터 값에 변화가 생겨서 준비했던 명령어들이 필요 없게 되는 경우.

            - 분기 예측 : 분기를 미리 예측하고 그 주소를 인출하는 기술

         3. 구조적 위험 : 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하면서 발생하는 위험.

     1. 슈퍼스칼라

        1. 여러 개의 명령어 파이프라인을 포함한 구조

           ![스크린샷 2022-10-06 오후 3.07.26.png](/static/images/cs/cs05/19.png)

        2. 명령어 파이프 라인이 하나의 공장 라인이면, 슈퍼스칼라는 공장 라인이 여러 개
        3. 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 혹은 슈퍼스칼라 CPU
        4. 동시에 여러 명령어를 실행시키기 때문에, 모든 CPU에서 가능한 것은 아님
           → 멀티스레드 프로세서는 가능!
        5. 이론상 파이프라인 개수에 비례해서 처리 속도가 빨라지지만, 여러 개의 파이프라인을 사용하다보니 생기는 파이프라인 위험 때문에 실제 속도는 그렇지 못함.

1. 비순차적 명령어 처리

   1. 대부분의 CPU가 사용하는 기법!
   2. 파이프라이닝, 슈퍼스칼라 기법은 모두 순차적 처리

   ![스크린샷 2022-10-06 오후 3.13.23.png](/static/images/cs/cs05/20.png)

   위와 같은 경우 3번 명령어는 1번과 2번 명령어가 선행되야 하기 때문에 3번 아래에 있는 모든 명령어는

   3번이 완료되기를 기다려야 함. (여기서도 데이터 의존성 발생)

   하나, 3번 명령어를 제일 마지막에 실행된다면 3번 아래에 명령어들은 기다릴 필요 없이 수행 가능!

   ![스크린샷 2022-10-06 오후 3.15.36.png](/static/images/cs/cs05/21.png)

## 05 - 3 CISC와 RISC

CISC와 RISC의 차이는 무엇일까?

## 명령어 집합(ISA)

CPU가 이해할 수 있는 명령어들의 모음

CPU마다 이해할 수 있는 ISA가 다를 수 있다.

![스크린샷 2022-10-06 오후 3.36.30.png](/static/images/cs/cs05/22.png)

즉, CPU가 달라지면 이해할 수 있는 ISA가 같이 달라지고 명령어가 달라지며, 컴퓨터가 이해할 수 있는 어셈블리어로 컴파일 할 경우, 다른 결과로 나누어진다.

![스크린샷 2022-10-06 오후 3.38.13.png](/static/images/cs/cs05/23.png)

반대로 말하면, ISA가 같은 CPU끼리는 명령어를 서로 이해할 수 있고, 다른 CPU 끼리는 서로의 명령어를 이해할 수 없기 때문에 ISA는 CPU의 언어인 셈!!

→ ISA 따라 CPU의 생김새, 명령어 해석 방식, 레지스터의 종류와 갯수, 메모리 관리 방법등이 달라짐.

## CISC

**특징**

- ‘복잡한 명령어 집합을 활용하는 컴퓨터’
- 대표적으로 x86, x86-64
- 다양한 명령어를 사용하기 위해 형태와 크기가 다양한 가변 길이 명령어를 활용.
- 메모리 접근 방식 또한 다양
  ![스크린샷 2022-10-06 오후 3.44.39.png](/static/images/cs/cs05/24.png)

**장점**

- 여러 명령어를 가지고 있기 때문에 RISC보다 짧은 용량으로 컴파일 가능.

**단점**

- 명령어가 복잡하고 다양해서 명령어의 크기와 실행 시간이 일정하지 않음.
- 여러 클럭 주기가 필요함.
- 효율적으로 파이프 라인을 사용하기 힘듦.
- 사실상 사용되는 명령어의 종류는 적고, 복잡한 기능을 자주 사용하지 않음.

## RISC

- CISC에 비해 명령어의 종류가 적다.
- 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향
- 고정 길이 명령어 활용!
  ![스크린샷 2022-10-06 오후 3.53.50.png](/static/images/cs/cs05/25.png)
- RISC는 메모리에 접근하는 명령어가 load, store 두 개로 제한

→ load - store 구조라고 부르기도 함.

- RISC는 메모리 접근을 줄이고 레지스터를 적극적으로 활용.
- 일반적인 경우보다 범용 레지스터 개수도 더 많다.
  ![오른쪽 RISC 방식의 명령어가 더 많다. ](/static/images/cs/cs05/26.png)
  오른쪽 RISC 방식의 명령어가 더 많다.
  **정리!**
  ![스크린샷 2022-10-06 오후 3.57.28.png](/static/images/cs/cs05/27.png)
  어렵다 어려워.. CPU…

---

##### 해당 스터디는 팀원들과 함께 진행한 스터디이기에 모든 장을 혼자서 발표한 것이 아닙니다.

##### 다른 장도 궁금하다면 [노션](https://amplified-neptune-cfd.notion.site/HBT-ede9d443e5484d07b4ee305a9106751a)을 방문해주세요 :)
