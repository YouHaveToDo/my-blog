---
title: 혼자 공부하는 컴퓨터구조와 운영체제) 15. 파일 시스템
date: '2022-10-26'
tags: ['컴퓨터구조', '운영체제']
draft: false
summary: what is file? 파일이란? 의미 있고 관련 있는 정보를 모든 논리적 단위
images: []
---

# 15. 파일 시스템 (코비)

# **what is file ?**

**파일이란? 의미 있고 관련 있는 정보를 모든 논리적 단위**

![스크린샷 2022-10-26 오후 1.30.40.png](/static/images/cs/cs15/01.png)

# 파일에는 어떤 의미 있고 관련 있는 정보가 있을까?

## 파일 이름

## 파일 실행 정보(샐리 숙제)

## 부가 정보

우리는 파일의 부가 정보를 속성 또는 메타데이터라고 부릅니다.

## 파일의 속성과 유형

![여러 속성이 있지만 오늘은 파일 유형에 대해 알아보자!](/static/images/cs/cs15/02.png)

여러 속성이 있지만 오늘은 파일 유형에 대해 알아보자!

**유형이란? 운영체제가 인지하는 파일의 종류!**

![스크린샷 2022-10-26 오후 1.47.31.png](/static/images/cs/cs15/03.png)

유형을 알기 위해 사용하는 방식이 파일 뒤에 이름을 붙이는 확장자

![스크린샷 2022-10-26 오후 1.48.31.png](/static/images/cs/cs15/04.png)

다른 파일 유형들은 알겠는데 목적 파일이 뭔지 모르겠다!

![목적 파일이 뭔지 모르겠다…](/static/images/cs/cs15/05.png)

목적 파일이 뭔지 모르겠다…

## 목적파일이란?

컴파일러나 어셈블러가 소스파일을 컴파일(컴파일 의미를 알아보면 원시코드에서 목적 코드(파일)로

변경하는 것) 또는 어셈블해서 생성하는 파일

![대충 기계어와 같은 바이너리 코드라는 거지?](/static/images/cs/cs15/06.png)

대충 기계어와 같은 바이너리 코드라는 거지?

**그러면 파일은 누가 관리하냐 ?** 이것 역시 운영체제가 관리 파일 관리를 위해 운영체제가 시스템 호출 제공

![운영체제: 또 나야 ?](/static/images/cs/cs15/07.png)

운영체제: 또 나야 ?

![응 안 외어~~](/static/images/cs/cs15/07-1.png)

응 안 외어~~

## 디렉토리

파일을 관리하기 위해 사용하는 것이 디렉토리 !!

![스크린샷 2022-10-26 오후 2.12.41.png](/static/images/cs/cs15/08.png)

![윈도우에서는 폴더라고 함](/static/images/cs/cs15/09.png)

윈도우에서는 폴더라고 함

- 과거 모든 파일이 하나의 폴더에 존재했습니다. 이와 같은 구조를 **1단계 디렉토리**라고 함.

![looks like 젠이츠](/static/images/cs/cs15/10.png)

looks like 젠이츠

- 이후 컴퓨터 과학이 발전하고 점차 구조가 복잡해지면서 트리 구조 디렉토리 생김
  - 디렉토리도 자식과 부모 관계가 있고 최상위 디렉토리를 루트 디렉토리라고 함.
  - 이렇게 복잡해지면서 파일 위치와 이름 짓는 경로라는 개념이 생김
    - 절대 경로 = 루트에서 자기 자신의 위치까지
    - 상대 경로 = 현재 디렉토리에서 자신의 경로
      ![아시겠지만!](/static/images/cs/cs15/11.png)
      아시겠지만!

그리고 … 디렉토리도 운영체제가 관리하고 시스템 호출을 제공합니다.

![스크린샷 2022-10-26 오후 2.24.53.png](/static/images/cs/cs15/12.png)

![응 안 외어~~ 22222222](/static/images/cs/cs15/13.png)

응 안 외어~~ 22222222

사실 디렉토리도 파일이라고 합니다…

- 디렉토리는 내부 해당 디렉토리에 담겨 있는 대상과 관련된 정보를 담고 있습니다.
  - 그 정보는 테이블 형태로 구성되며 보조기억장치에 테이블 형태로 저장합니다.
  - 각각의 행에 담기는 정보는 파일 시스템마다 차이가 있지만 공통적으로 디렉토리에 있는 파일과 파일이 보조기억장치 내에 저장된 위치를 유추할 수 있는 정보를 저장합니다.

# 파일 시스템

파일과 디렉토리를 보조기억장치에 저장하고 접근 할 수 있게 하는 운영체제 내부 프로그램

### **파티셔닝**

저장 장치의 논리적인 영역을 구획하는 작업

![C 드라이브와 D 드라이브](/static/images/cs/cs15/14.png)

C 드라이브와 D 드라이브

### 파티션

파티셔닝을 통해 나누어진 구역

### 포매팅

저장장치를 완전삭제 초기화 시키는 것 ?

![스크린샷 2022-10-26 오후 2.34.57.png](/static/images/cs/cs15/15.png)

**파일 시스템을 설정하는 것 즉, 파일을 어떻게 저장하고 관리할 것인지 결정**

- 파티션마다 다른 파일 시스템 설정 가능

우리가 구매하여 사용하는 저장장치의 경우 미리 파티셔닝과 포매팅이 되어 있습니다.

포매팅에 따라 맥이나 윈도우에서 사용할 수 없는 제품이 있습니다.

[맥, 윈도우 호환 USB 만들기](http://taewan.kim/tip/usb_format_in_osx/)

### 파일 할당 방법

운영체제는 파일과 디렉토리를 블록 단위로 저장하고 읽는다.

당연히 크기에 따라 사용하는 블록의 갯수도 달라짐.

파일을 보조기억장치에 할당하는 방법은 크게 2가지, 작게 3가지

![스크린샷 2022-10-26 오후 2.38.17.png](/static/images/cs/cs15/16.png)

### 연속할당

**보조기억장치에 연속적인 블록에 파일 저장**

접근하기 위해서 첫 번째 블록 주소와 블록 길이만 알면 됨.

단순하다는 장점이 있지만 외부 단편화 문제가 생김.

### 연결 할당

- 연속 할당 문제 해결 가능!!
- 각 블록 일부에 다음 블록 주소 저장, 파일이 여러 블록으로 흩어져 저장돼도 무방.
- 연결 할당도 마찬가지로 첫번째 블록과 길이만 저장
- 장단점
  1. 외부 단편화 문제를 해결하는 장점도 있지만 순서대로 블록을 읽어야 해서 파일 내 임의의 위치에 접근하는 임의 접근 속도가 느리고 파일이 커질수록 비효율적이다.
  2. 하드웨어 고장으로 블록이 하나라도 오류나면 다음 블록으로 접근할 수 없다.

### 색인 할당

- 파일의 모든 블록 주소를 색인 블록이라는 블록에 저장하는 방식.
- 색인 블록만 있으면 해당 파일 데이터에 접근 가능. 그래서 색인 할당을 사용하는 파일 시스템은 디렉토리
  엔트리에 파일 이름과 색인 블록 주소를 명시. (샐리 숙제 다음주까지)

## 파일 시스템

FAT 파일 시스템 , 유닉스 파일 시스템

### 파일 할당 테이블 (FAT)

- 각 블록에 포함된 다음 블록 주소들을 한데 모아 테이블 형태로 관리 .. 하는 형태의 테이블
- FAT를 사용하는 파일 시스템을 FAT 파일 시스템 .. 당연한 소리
  ![요게 FAT](/static/images/cs/cs15/17.png)
  요게 FAT

FAT는 하드디스크 파티션 시작 부분에 있다.

그리고 메모리에 적재되면 속도도 매우 빨라지고 임의 접근 속도도 개선됨.

**문제) /home/minchul/a.sh 접근해보시오.**

![스크린샷 2022-10-26 오전 1.54.57.png](/static/images/cs/cs15/18.png)

## 유닉스 파일 시스템

- 색인 할당 기반
  - 유닉스 파일 시스템에서는 색인 블록을 i-node (index-node) 이라고 합니다.
- i-node에는 최대 15개의 블록 주소를 저장 가능, 15개 넘어가면 곤란해…
  ![스크린샷 2022-10-26 오후 2.50.05.png](/static/images/cs/cs15/19.png)
- 직접블록: 파일 데이터가 저장된 블록

### 유닉스 파일 시스템 실행 방식!

![스크린샷 2022-10-26 오전 2.05.22.png](/static/images/cs/cs15/20.png)

1.  12개까진 직접 블록 주소 저장
    - ![스크린샷 2022-10-26 오후 8.24.37.png](/static/images/cs/cs15/22.png)
2.  1번이 안되면 13번째 주소에 단일 간접 블록 주소 저장

    단일 간접 블록 = 파일 데이터를 저장한 블록 주소가 저장된 블록

    ![스크린샷 2022-10-26 오후 2.55.14.png](/static/images/cs/cs15/23.png)

3.  2번이 안되면 14번째 주소에 이중 간접 블록 주소 저장

    이중 간접 블록 = 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록

    ![스크린샷 2022-10-26 오후 8.25.09.png](/static/images/cs/cs15/24.png)

4.  3번이 안되면 15번째 주소에 삼중 간접 블록 주소 저장

    삼중 간접 블록 = 이중 간접 블록이 저장된 블록

    ![Untitled](/static/images/cs/cs15/25.png)

![스크린샷 2022-10-26 오후 2.53.32.png](/static/images/cs/cs15/21.png)

---

##### 해당 스터디는 팀원들과 함께 진행한 스터디이기에 모든 장을 혼자서 발표한 것이 아닙니다.

##### 다른 장도 궁금하다면 [노션](https://amplified-neptune-cfd.notion.site/HBT-ede9d443e5484d07b4ee305a9106751a)을 방문해주세요 :)
